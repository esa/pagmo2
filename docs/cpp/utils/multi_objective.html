 <!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Multi-objective optimization utilities &#8212; pagmo 2.7 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pagmo.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../_static/logo_favico.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Constrained optimization utilities" href="constrained.html" />
    <link rel="prev" title="Thread island" href="../islands/thread_island.html" />
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto|Comfortaa|Space+Mono"> 
  </head>
  <body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html"><span><img src="../../../_static/logo_small_html.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>2.7</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../index.html">Home</a></li>
                <li><a href="../../../install.html">Install</a></li>
                <li><a href="../../../quickstart.html">Quickstart</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">All <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../install.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../install.html#python">Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick start</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../quickstart.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../quickstart.html#python">Python</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../algorithm_list.html">List of algorithms (UDAs) available in pagmo/pygmo</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../algorithm_list.html#heuristic-global-optimization">Heuristic Global Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algorithm_list.html#meta-algorithms">Meta-algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algorithm_list.html#local-optimization">Local optimization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../problem_list.html">List of problems (UDPs) available in pagmo/pygmo</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../problem_list.html#scalable-problems">Scalable problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../problem_list.html#problem-suites">Problem suites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../problem_list.html#meta-problems">Meta-problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../island_list.html">List of islands (UDIs) available in pagmo/pygmo</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../cpp_docs.html">C++ Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#core-classes">Core classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#implemented-algorithms">Implemented algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#implemented-problems">Implemented problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#implemented-islands">Implemented islands</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../cpp_docs.html#utilities">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#miscellanea">Miscellanea</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../python/python_docs.html">Python Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../python/python_docs.html#core-classes">Core classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/python_docs.html#implemented-problems-algorithms-and-islands">Implemented problems, algorithms and islands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/python_docs.html#utilities">Utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../python/tutorials/python_tut.html">Python tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../python/tutorials/python_tut.html#basics">Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/tutorials/python_tut.html#coding-your-own-problem-udp">Coding your own problem (UDP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/tutorials/python_tut.html#coding-your-own-island-udi">Coding your own island (UDI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/tutorials/python_tut.html#local-optimization">Local optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/tutorials/python_tut.html#multi-objective-optimization">Multi-objective optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/tutorials/python_tut.html#hypervolumes">Hypervolumes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/tutorials/python_tut.html#advanced-examples">Advanced Examples</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../credits.html#main-developers">Main developers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id1">2.7 (2018-04-13)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id2">2.6 (2017-11-18)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id3">2.5 (2017-11-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id5">2.4 (2017-06-09)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id9">2.3 (2017-05-19)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id12">2.2 (2017-05-12)</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">This Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Multi-objective optimization utilities</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="multi-objective-optimization-utilities">
<span id="cpp-multi-objective-utils"></span><h1>Multi-objective optimization utilities<a class="headerlink" href="#multi-objective-optimization-utilities" title="Permalink to this headline">¶</a></h1>
<p>A number of utilities to compute quantities that are of relevance to
the determination of non dominated fronts, Pareto dominance criterias and
more in general, to multi-objective optimization tasks.</p>
<hr class="docutils" />
<dl class="function">
<dt id="_CPPv2N5pagmo16pareto_dominanceERK13vector_doubleRK13vector_double">
<span id="pagmo::pareto_dominance__vector_doubleCR.vector_doubleCR"></span><span class="target" id="namespacepagmo_1ab72c593724e2370b7ee4f8a9828e5984"></span>bool <code class="descclassname">pagmo::</code><code class="descname">pareto_dominance</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> &amp;<em>obj1</em>, <em class="property">const</em> <a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> &amp;<em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5pagmo16pareto_dominanceERK13vector_doubleRK13vector_double" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pareto-dominance. </p>
<p>Return true if <code class="docutils literal"><span class="pre">obj1</span></code> Pareto dominates <code class="docutils literal"><span class="pre">obj2</span></code>, false otherwise. Minimization is assumed.</p>
<p>Each pair of corresponding elements in <code class="docutils literal"><span class="pre">obj1</span></code> and <code class="docutils literal"><span class="pre">obj2</span></code> is compared: if all elements in <code class="docutils literal"><span class="pre">obj1</span></code> are less or equal to the corresponding element in <code class="docutils literal"><span class="pre">obj2</span></code>, but at least one is different, <code class="docutils literal"><span class="pre">true</span></code> will be returned. Otherwise, <code class="docutils literal"><span class="pre">false</span></code> will be returned.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">obj1</span></code> is dominating <code class="docutils literal"><span class="pre">obj2</span></code>, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">obj1</span></code>: first vector of objectives. </li>
<li><code class="docutils literal"><span class="pre">obj2</span></code>: second vector of objectives.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">std::invalid_argument</span></code>: if the dimensions of the two objectives are different </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="_CPPv2N5pagmo22non_dominated_front_2dERKNSt6vectorI13vector_doubleEE">
<span id="pagmo::non_dominated_front_2d__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1af4a927a911a2d03e655bf13e5816900a"></span>std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>::size_type&gt; <code class="descclassname">pagmo::</code><code class="descname">non_dominated_front_2d</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>input_objs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5pagmo22non_dominated_front_2dERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non dominated front 2D (Kung’s algorithm) </p>
<p>Finds the non dominated front of a set of two dimensional objectives. Complexity is O(N logN) and is thus lower than the complexity of calling <a class="reference internal" href="#namespacepagmo_1a27aeb5efb01fca4422fc124eec221199"><span class="std std-ref">pagmo::fast_non_dominated_sorting</span></a></p>
<p>See: Jensen, Mikkel T. “Reducing the run-time complexity of multiobjective EAs: The NSGA-II and other algorithms.” IEEE Transactions on Evolutionary Computation 7.5 (2003): 503-515.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A <code class="docutils literal"><span class="pre">std::vector</span></code> containing the indexes of the points in the non-dominated front</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">input_objs</span></code>: an <code class="docutils literal"><span class="pre">std::vector</span></code> containing the points (i.e. vector of objectives)</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">std::invalid_argument</span></code>: If the objective vectors are not all containing two-objectives </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="_CPPv2N5pagmo17crowding_distanceERKNSt6vectorI13vector_doubleEE">
<span id="pagmo::crowding_distance__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1ad503682786287cfe57f565e335524633"></span><a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> <code class="descclassname">pagmo::</code><code class="descname">crowding_distance</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>non_dom_front</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5pagmo17crowding_distanceERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Crowding distance. </p>
<p>An implementation of the crowding distance. Complexity is <span class="math">\( O(MNlog(N))\)</span> where <span class="math">\(M\)</span> is the number of objectives and <span class="math">\(N\)</span> is the number of individuals. The function assumes the input is a non-dominated front. Failiure to this condition will result in undefined behaviour.</p>
<p>See: Deb, Kalyanmoy, et al. “A fast elitist non-dominated sorting genetic algorithm
for multi-objective optimization: NSGA-II.” Parallel problem solving from nature PPSN VI. Springer Berlin Heidelberg, 2000.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a vector_double containing the crowding distances. Example: {2, inf, inf}</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">non_dom_front</span></code>: An <code class="docutils literal"><span class="pre">std::vector&lt;vector_double&gt;</span></code> containing a non dominated front. Example {{0,0},{-1,1},{2,-2}}</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">std::invalid_argument</span></code>: If <code class="docutils literal"><span class="pre">non_dom_front</span></code> does not contain at least two points </li>
<li><code class="docutils literal"><span class="pre">std::invalid_argument</span></code>: If points in <code class="docutils literal"><span class="pre">do</span></code> not all have at least two objectives </li>
<li><code class="docutils literal"><span class="pre">std::invalid_argument</span></code>: If points in <code class="docutils literal"><span class="pre">non_dom_front</span></code> do not all have the same dimensionality </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="_CPPv2N5pagmo26fast_non_dominated_sortingERKNSt6vectorI13vector_doubleEE">
<span id="pagmo::fast_non_dominated_sorting__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1a27aeb5efb01fca4422fc124eec221199"></span>fnds_return_type <code class="descclassname">pagmo::</code><code class="descname">fast_non_dominated_sorting</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5pagmo26fast_non_dominated_sortingERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fast non dominated sorting. </p>
<p>An implementation of the fast non dominated sorting algorithm. Complexity is <span class="math">\( O(MN^2)\)</span> where <span class="math">\(M\)</span> is the number of objectives and <span class="math">\(N\)</span> is the number of individuals.</p>
<p>See: Deb, Kalyanmoy, et al. “A fast elitist non-dominated sorting genetic algorithm
for multi-objective optimization: NSGA-II.” Parallel problem solving from nature PPSN VI. Springer Berlin Heidelberg, 2000.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an std::tuple containing:<ul class="simple">
<li>the non dominated fronts, an <code class="docutils literal"><span class="pre">std::vector&lt;std::vector&lt;vector_double::size_type&gt;&gt;</span></code> containing the non dominated fronts. Example {{1,2},{3},{0}}</li>
<li>the domination list, an <code class="docutils literal"><span class="pre">std::vector&lt;std::vector&lt;vector_double::size_type&gt;&gt;</span></code> containing the domination list, i.e. the indexes of all individuals dominated by the individual at position <span class="math">\(i\)</span>. Example {{},{},{0,3},{0}}</li>
<li>the domination count, an <code class="docutils literal"><span class="pre">std::vector&lt;vector_double::size_type&gt;</span></code> containing the number of individuals that dominate the individual at position <span class="math">\(i\)</span>. Example {2, 0, 0, 1}</li>
<li>the non domination rank, an <code class="docutils literal"><span class="pre">std::vector&lt;vector_double::size_type&gt;</span></code> containing the index of the non dominated front to which the individual at position <span class="math">\(i\)</span> belongs. Example {2,0,0,1}</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">points</span></code>: An std::vector containing the objectives of different individuals. Example {{1,2,3},{-2,3,7},{-1,-2,-3},{0,0,0}}</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">std::invalid_argument</span></code>: If the size of <code class="docutils literal"><span class="pre">points</span></code> is not at least 2 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="_CPPv2N5pagmo18sort_population_moERKNSt6vectorI13vector_doubleEE">
<span id="pagmo::sort_population_mo__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1a564410c4164043e81c3c0d2d44f34b44"></span>std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>::size_type&gt; <code class="descclassname">pagmo::</code><code class="descname">sort_population_mo</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>input_f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5pagmo18sort_population_moERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sorts a population in multi-objective optimization. </p>
<p>Sorts a population (intended here as an <code class="docutils literal"><span class="pre">std::vector&lt;vector_double&gt;</span></code> containing the objective vectors) with respect to the following strict ordering:<ul class="simple">
<li><span class="math">\(f_1 \prec f_2\)</span> if the non domination ranks are such that <span class="math">\(i_1 &lt; i_2\)</span>. In case <span class="math">\(i_1 = i_2\)</span>, then <span class="math">\(f_1 \prec f_2\)</span> if the crowding distances are such that <span class="math">\(d_1 &gt; d_2\)</span>.</li>
</ul>
</p>
<p>Complexity is <span class="math">\( O(MN^2)\)</span> where <span class="math">\(M\)</span> is the number of objectives and <span class="math">\(N\)</span> is the number of individuals.</p>
<p>This function will also work for single objective optimization, i.e. with 1 objective in which case, though, it is more efficient to sort using directly one of the following forms:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="n">sort</span><span class="p">(</span><span class="n">input_f</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input_f</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="n">auto</span> <span class="n">a</span><span class="p">,</span> <span class="n">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];});</span>
</pre></div>
</div>
 <div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector_double</span><span class="p">::</span><span class="n">size_type</span><span class="o">&gt;</span> <span class="n">idx</span><span class="p">(</span><span class="n">input_f</span><span class="o">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">std</span><span class="p">::</span><span class="n">iota</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">idx</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">vector_double</span><span class="p">::</span><span class="n">size_type</span><span class="p">(</span><span class="mi">0</span><span class="n">u</span><span class="p">));</span>
<span class="n">std</span><span class="p">::</span><span class="n">sort</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">idx</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="n">auto</span> <span class="n">a</span><span class="p">,</span> <span class="n">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">input_f</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">input_f</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">0</span><span class="p">];});</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <code class="docutils literal"><span class="pre">std::vector</span></code> containing the indexes of the sorted objectives vectors. Example {1,2,0}</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">input_f</span></code>: Input objectives vectors. Example {{0.25,0.25},{-1,1},{2,-2}};</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">unspecified</span></code>: all exceptions thrown by <a class="reference internal" href="#namespacepagmo_1a27aeb5efb01fca4422fc124eec221199"><span class="std std-ref">pagmo::fast_non_dominated_sorting</span></a> and <a class="reference internal" href="#namespacepagmo_1ad503682786287cfe57f565e335524633"><span class="std std-ref">pagmo::crowding_distance</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="_CPPv2N5pagmo16select_best_N_moERKNSt6vectorI13vector_doubleEEN13vector_double9size_typeE">
<span id="pagmo::select_best_N_mo__std::vector:vector_double:CR.vector_double::size_type"></span><span class="target" id="namespacepagmo_1a6d073423ae258fc2b609239219b4bcab"></span>std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>::size_type&gt; <code class="descclassname">pagmo::</code><code class="descname">select_best_N_mo</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>input_f</em>, <a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>::size_type <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5pagmo16select_best_N_moERKNSt6vectorI13vector_doubleEEN13vector_double9size_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Selects the best N individuals in multi-objective optimization. </p>
<p>Selects the best N individuals out of a population, (intended here as an <code class="docutils literal"><span class="pre">std::vector&lt;vector_double&gt;</span></code> containing the objective vectors). The strict ordering used is the same as that defined in <a class="reference internal" href="#namespacepagmo_1a564410c4164043e81c3c0d2d44f34b44"><span class="std std-ref">pagmo::sort_population_mo</span></a>.</p>
<p>Complexity is <span class="math">\( O(MN^2)\)</span> where <span class="math">\(M\)</span> is the number of objectives and <span class="math">\(N\)</span> is the number of individuals.</p>
<p>While the complexity is the same as that of <a class="reference internal" href="#namespacepagmo_1a564410c4164043e81c3c0d2d44f34b44"><span class="std std-ref">pagmo::sort_population_mo</span></a>, this function returns a permutation of:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pagmo</span><span class="p">::</span><span class="n">sort_population_mo</span><span class="p">(</span><span class="n">input_f</span><span class="p">)</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p>but it is faster than the above code: it avoids to compute the crowidng distance for all individuals and only computes it for the last non-dominated front that contains individuals included in the best N.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <code class="docutils literal"><span class="pre">std::vector</span></code> containing the indexes of the best N objective vectors. Example {2,1}</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">input_f</span></code>: Input objectives vectors. Example {{0.25,0.25},{-1,1},{2,-2}}; </li>
<li><code class="docutils literal"><span class="pre">N</span></code>: Number of best individuals to return</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">unspecified</span></code>: all exceptions thrown by <a class="reference internal" href="#namespacepagmo_1a27aeb5efb01fca4422fc124eec221199"><span class="std std-ref">pagmo::fast_non_dominated_sorting</span></a> and <a class="reference internal" href="#namespacepagmo_1ad503682786287cfe57f565e335524633"><span class="std std-ref">pagmo::crowding_distance</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="_CPPv2N5pagmo5idealERKNSt6vectorI13vector_doubleEE">
<span id="pagmo::ideal__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1a03f1dbeb382df95af4ac18c4db64c139"></span><a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> <code class="descclassname">pagmo::</code><code class="descname">ideal</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5pagmo5idealERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Ideal point. </p>
<p>Computes the ideal point of an input population, (intended here as an <code class="docutils literal"><span class="pre">std::vector&lt;vector_double&gt;</span></code> containing the objective vectors).</p>
<p>Complexity is <span class="math">\( O(MN)\)</span> where <span class="math">\(M\)</span> is the number of objectives and <span class="math">\(N\)</span> is the number of individuals.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A vector_double containing the ideal point. Example: {-1,-2,231}</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">points</span></code>: Input objectives vectors. Example {{-1,3,597},{1,2,3645},{2,9,789},{0,0,231},{6,-2,4576}};</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">std::invalid_argument</span></code>: if the input objective vectors are not all of the same size </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="_CPPv2N5pagmo5nadirERKNSt6vectorI13vector_doubleEE">
<span id="pagmo::nadir__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1a88a611f76187a58dcdcfb813ef4ffcb9"></span><a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> <code class="descclassname">pagmo::</code><code class="descname">nadir</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5pagmo5nadirERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Nadir point. </p>
<p>Computes the nadir point of an input population, (intended here as an <code class="docutils literal"><span class="pre">std::vector&lt;vector_double&gt;</span></code> containing the objective vectors).</p>
<p>Complexity is <span class="math">\( O(MN^2)\)</span> where <span class="math">\(M\)</span> is the number of objectives and <span class="math">\(N\)</span> is the number of individuals.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A vector_double containing the nadir point. Example: {10,7} </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">points</span></code>: Input objective vectors. Example {{0,7},{1,5},{2,3},{4,2},{7,1},{10,0},{6,6},{9,15}}</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="_CPPv2N5pagmo21decomposition_weightsEN13vector_double9size_typeEN13vector_double9size_typeERKNSt6stringERN6detail18random_engine_typeE">
<span id="pagmo::decomposition_weights__vector_double::size_type.vector_double::size_type.ssCR.detail::random_engine_typeR"></span><span class="target" id="namespacepagmo_1a0fdfd2f9b4cee07e14a89e0075a54baf"></span>std::vector&lt;<a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; <code class="descclassname">pagmo::</code><code class="descname">decomposition_weights</code><span class="sig-paren">(</span><a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>::size_type <em>n_f</em>, <a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>::size_type <em>n_w</em>, <em class="property">const</em> std::string &amp;<em>method</em>, detail::random_engine_type &amp;<em>r_engine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5pagmo21decomposition_weightsEN13vector_double9size_typeEN13vector_double9size_typeERKNSt6stringERN6detail18random_engine_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Decomposition weights generation. </p>
<p>Generates a requested number of weight vectors to be used to decompose a multi-objective problem. Three methods are available:<ul class="simple">
<li>”grid” generates weights on an uniform grid. This method may only be used when the number of requested weights to be genrated is such that a uniform grid is indeed possible. In two dimensions this is always the case, but in larger dimensions uniform grids are possible only in special cases</li>
<li>”random” generates weights randomly distributing them uniformly on the simplex (weights are such that <span class="math">\(\sum_i \lambda_i = 1\)</span>)</li>
<li>”low discrepancy” generates weights using a low-discrepancy sequence to, eventually, obtain a better coverage of the Pareto front. Halton sequence is used since low dimensionalities are expected in the number of objectives (i.e. less than 20), hence Halton sequence is deemed as appropriate.</li>
</ul>
</p>
<p><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All genration methods are guaranteed to generate weights on the simplex (<span class="math">\(\sum_i \lambda_i = 1\)</span>). All
weight generation methods are guaranteed to generate the canonical weights [1,0,0,…], [0,1,0,..], … first.</p>
</div>
</p>
<p>Example: to generate 10 weights distributed somehow regularly to decompose a three dimensional problem: <div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">detail</span><span class="p">::</span><span class="n">random_engine_type</span> <span class="n">r_engine</span><span class="p">();</span>
<span class="n">auto</span> <span class="n">lambdas</span> <span class="o">=</span> <span class="n">decomposition_weights</span><span class="p">(</span><span class="mi">3</span><span class="n">u</span><span class="p">,</span> <span class="mi">10</span><span class="n">u</span><span class="p">,</span> <span class="s2">&quot;low discrepancy&quot;</span><span class="p">,</span> <span class="n">r_engine</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <code class="docutils literal"><span class="pre">std:vector</span></code> containing the weight vectors</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">n_f</span></code>: dimension of each weight vector (i.e. fitness dimension) </li>
<li><code class="docutils literal"><span class="pre">n_w</span></code>: number of weights to be generated </li>
<li><code class="docutils literal"><span class="pre">method</span></code>: methods to generate the weights of the decomposed problems. One of “grid”, “random”, “low discrepancy” </li>
<li><code class="docutils literal"><span class="pre">r_engine</span></code>: random engine</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">if</span></code>: <code class="docutils literal"><span class="pre">nf</span></code> and <code class="docutils literal"><span class="pre">nw</span></code> are not compatible with the selected weight generation method or if <code class="docutils literal"><span class="pre">method</span></code> is not one of “grid”, “random” or “low discrepancy” </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="_CPPv2N5pagmo20decompose_objectivesERK13vector_doubleRK13vector_doubleRK13vector_doubleRKNSt6stringE">
<span id="pagmo::decompose_objectives__vector_doubleCR.vector_doubleCR.vector_doubleCR.ssCR"></span><span class="target" id="namespacepagmo_1ab619aca81b1ad186aab7f3b67418954b"></span><a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> <code class="descclassname">pagmo::</code><code class="descname">decompose_objectives</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> &amp;<em>f</em>, <em class="property">const</em> <a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> &amp;<em>weight</em>, <em class="property">const</em> <a class="reference internal" href="../types.html#_CPPv2N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> &amp;<em>ref_point</em>, <em class="property">const</em> std::string &amp;<em>method</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5pagmo20decompose_objectivesERK13vector_doubleRK13vector_doubleRK13vector_doubleRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Decomposes a vector of objectives. </p>
<p>A vector of objectives is reduced to one only objective using a decomposition technique.</p>
<p>Three different <em>decomposition methods</em> are here made available:</p>
<p><ul class="simple">
<li>weighted decomposition,</li>
<li>Tchebycheff decomposition,</li>
<li>boundary interception method (with penalty constraint).</li>
</ul>
</p>
<p>In the case of <span class="math">\(n\)</span> objectives, we indicate with: <span class="math">\( \mathbf f(\mathbf x) = [f_1(\mathbf x), \ldots, f_n(\mathbf x)] \)</span> the vector containing the original multiple objectives, with: <span class="math">\( \boldsymbol \lambda = (\lambda_1, \ldots, \lambda_n) \)</span> an <span class="math">\(n\)</span>-dimensional weight vector and with: <span class="math">\( \mathbf z^* = (z^*_1, \ldots, z^*_n) \)</span> an <span class="math">\(n\)</span>-dimensional reference point. We also ussume <span class="math">\(\lambda_i &gt; 0, \forall i=1..n\)</span> and <span class="math">\(\sum_i \lambda_i = 1\)</span>.</p>
<p>The resulting single objective is thus defined as:</p>
<p><ul class="simple">
<li>weighted decomposition: <span class="math">\( f_d(\mathbf x) = \boldsymbol \lambda \cdot \mathbf f \)</span>,</li>
<li>Tchebycheff decomposition: <span class="math">\( f_d(\mathbf x) = \max_{1 \leq i \leq m} \lambda_i \vert f_i(\mathbf x) - z^*_i \vert \)</span>,</li>
<li>boundary interception method (with penalty constraint): <span class="math">\( f_d(\mathbf x) = d_1 + \theta d_2\)</span>,</li>
</ul>
</p>
<p>where <span class="math">\(d_1 = (\mathbf f - \mathbf z^*) \cdot \hat {\mathbf i}_{\lambda}\)</span>, <span class="math">\(d_2 = \vert (\mathbf f - \mathbf z^*) - d_1 \hat {\mathbf i}_{\lambda})\vert\)</span> and <span class="math">\( \hat {\mathbf i}_{\lambda} = \frac{\boldsymbol \lambda}{\vert \boldsymbol \lambda \vert}\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the decomposed objective.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">f</span></code>: input vector of objectives. </li>
<li><code class="docutils literal"><span class="pre">weight</span></code>: the weight to be used in the decomposition. </li>
<li><code class="docutils literal"><span class="pre">ref_point</span></code>: the reference point to be used if either “tchebycheff” or “bi”. was indicated as a decomposition method. Its value is ignored if “weighted” was indicated. </li>
<li><code class="docutils literal"><span class="pre">method</span></code>: decomposition method: one of “weighted”, “tchebycheff” or “bi”</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">std::invalid_argument</span></code>: if <code class="docutils literal"><span class="pre">f</span></code>, <code class="docutils literal"><span class="pre">weight</span></code> and <code class="docutils literal"><span class="pre">ref_point</span></code> have different sizes </li>
<li><code class="docutils literal"><span class="pre">std::invalid_argument</span></code>: if <code class="docutils literal"><span class="pre">method</span></code> is not one of “weighted”, “tchebycheff” or “bi” </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017, pagmo development team.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.<br/>
    </p>
  </div>
</footer>
  </body>
</html>