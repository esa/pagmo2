 <!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Problem class &#8212; pagmo 2.11 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pagmo.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/logo_favico.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Population class" href="py_population.html" />
    <link rel="prev" title="Algorithm class" href="py_algorithm.html" />
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto|Comfortaa|Space+Mono"> 
  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/logo_small_html.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>2.11</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../index.html">Home</a></li>
                <li><a href="../../install.html">Install</a></li>
                <li><a href="../../quickstart.html">Quickstart</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">All <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#python">Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick start</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#python">Python</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../algorithm_list.html">List of algorithms (UDAs) available in pagmo/pygmo</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../algorithm_list.html#heuristic-global-optimization">Heuristic Global Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algorithm_list.html#local-optimization">Local optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algorithm_list.html#meta-algorithms">Meta-algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../problem_list.html">List of problems (UDPs) available in pagmo/pygmo</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../problem_list.html#scalable-problems">Scalable problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../problem_list.html#problem-suites">Problem suites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../problem_list.html#meta-problems">Meta-problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../island_list.html">List of islands (UDIs) available in pagmo/pygmo</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../cpp/cpp_docs.html">C++ Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../cpp/cpp_docs.html#core-classes">Core classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp/cpp_docs.html#implemented-algorithms">Implemented algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp/cpp_docs.html#implemented-problems">Implemented problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp/cpp_docs.html#implemented-islands">Implemented islands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp/cpp_docs.html#implemented-batch-evaluators">Implemented batch evaluators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp/cpp_docs.html#utilities">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp/cpp_docs.html#miscellanea">Miscellanea</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cpp/tutorials/cpp_tut.html">C++ tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../cpp/tutorials/cpp_tut.html#basics">Basics</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="python_docs.html">Python Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="python_docs.html#core-classes">Core classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="python_docs.html#implemented-problems-algorithms-islands-and-bfes">Implemented problems, algorithms, islands and bfes</a></li>
<li class="toctree-l2"><a class="reference internal" href="python_docs.html#utilities">Utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/python_tut.html">Python tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorials/python_tut.html#basics">Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/python_tut.html#coding-your-own-problem-udp">Coding your own problem (UDP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/python_tut.html#meta-problems">Meta-problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/python_tut.html#coding-your-own-island-udi">Coding your own island (UDI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/python_tut.html#local-optimization">Local optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/python_tut.html#multi-objective-optimization">Multi-objective optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/python_tut.html#hypervolumes">Hypervolumes</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/python_tut.html#advanced-examples">Advanced Examples</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../credits.html">Credits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../credits.html#main-developers">Main developers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#unreleased">2.11 (unreleased)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#id1">2.10 (2019-01-02)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#id4">2.9 (2018-08-31)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#id8">2.8 (2018-07-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#id12">2.7 (2018-04-13)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#id15">2.6 (2017-11-18)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#id17">2.5 (2017-11-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#id19">2.4 (2017-06-09)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#id23">2.3 (2017-05-19)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#id26">2.2 (2017-05-12)</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">This Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Problem class</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="problem-class">
<h1>Problem class<a class="headerlink" href="#problem-class" title="Permalink to this headline">¶</a></h1>
<img alt="../../_images/prob_no_text1.png" src="../../_images/prob_no_text1.png" />
<dl class="class">
<dt id="pygmo.problem">
<em class="property">class </em><code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">problem</code><span class="sig-paren">(</span><em class="sig-param">udp = null_problem()</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem" title="Permalink to this definition">¶</a></dt>
<dd><p>Problem class.</p>
<p>This class represents a generic <em>mathematical programming</em> or <em>evolutionary optimization</em> problem in the form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rl}
\mbox{find:}      &amp; \mathbf {lb} \le \mathbf x \le \mathbf{ub}\\
\mbox{to minimize: } &amp; \mathbf f(\mathbf x, s) \in \mathbb R^{n_{obj}}\\
\mbox{subject to:} &amp; \mathbf {c}_e(\mathbf x, s) = 0 \\
                  &amp; \mathbf {c}_i(\mathbf x, s) \le 0
\end{array}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf x \in \mathbb R^{n_{cx}} \times  \mathbb Z^{n_{ix}}\)</span> is called <em>decision vector</em> or
<em>chromosome</em>, and is made of <span class="math notranslate nohighlight">\(n_{cx}\)</span> real numbers and <span class="math notranslate nohighlight">\(n_{ix}\)</span> integers (all represented as doubles). The
total problem dimension is then indicated with <span class="math notranslate nohighlight">\(n_x = n_{cx} + n_{ix}\)</span>. <span class="math notranslate nohighlight">\(\mathbf{lb}, \mathbf{ub} \in
\mathbb R^{n_{cx}} \times  \mathbb Z^{n_{ix}}\)</span> are the <em>box-bounds</em>, <span class="math notranslate nohighlight">\(\mathbf f: \mathbb R^{n_{cx}} \times
\mathbb Z^{n_{ix}} \rightarrow \mathbb R^{n_{obj}}\)</span> define the <em>objectives</em>, <span class="math notranslate nohighlight">\(\mathbf c_e:  \mathbb R^{n_{cx}}
\times  \mathbb Z^{n_{ix}} \rightarrow \mathbb R^{n_{ec}}\)</span> are non linear <em>equality constraints</em>, and <span class="math notranslate nohighlight">\(\mathbf
c_i:  \mathbb R^{n_{cx}} \times  \mathbb Z^{n_{ix}} \rightarrow \mathbb R^{n_{ic}}\)</span> are non linear <em>inequality
constraints</em>. Note that the objectives and constraints may also depend from an added value <span class="math notranslate nohighlight">\(s\)</span> seeding the
values of any number of stochastic variables. This allows also for stochastic programming tasks to be represented by
this class. A tolerance is also considered for all constraints and set, by default, to zero. It can be modified
via the <a class="reference internal" href="#pygmo.problem.c_tol" title="pygmo.problem.c_tol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">c_tol</span></code></a> attribute.</p>
<p>In order to define an optimizaztion problem in pygmo, the user must first define a class
whose methods describe the properties of the problem and allow to compute
the objective function, the gradient, the constraints, etc. In pygmo, we refer to such
a class as a <strong>user-defined problem</strong>, or UDP for short. Once defined and instantiated,
a UDP can then be used to construct an instance of this class, <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>, which
provides a generic interface to optimization problems.</p>
<p>Every UDP must implement at least the following two methods:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method is expected to return the fitness of the input decision vector (concatenating
the objectives, the equality and the inequality constraints), while
<code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> is expected to return the box bounds of the problem,
<span class="math notranslate nohighlight">\((\mathbf{lb}, \mathbf{ub})\)</span>, which also implicitly define the dimension of the problem.
The <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> and <code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> methods of the UDP are accessible from the corresponding
<a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">pygmo.problem.fitness()</span></code></a> and <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">pygmo.problem.get_bounds()</span></code></a>
methods (see their documentation for information on how the two methods should be implemented
in the UDP and other details).</p>
<p>The two mandatory methods above allow to define a single objective, deterministic, derivative-free, unconstrained
optimization problem. In order to consider more complex cases, the UDP may implement one or more of the following
methods:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_nobj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_nec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_nic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_nix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">batch_fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dvs</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_batch_fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_gradient_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">gradient_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_hessians</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">hessians</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_hessians_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">hessians_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_set_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">set_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_extra_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>See the documentation of the corresponding methods in this class for details on how the optional
methods in the UDP should be implemented and on how they are used by <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.
Note that the exposed C++ problems can also be used as UDPs, even if they do not expose any of the
mandatory or optional methods listed above (see <a class="reference internal" href="problems/py_problems.html#py-problems"><span class="std std-ref">here</span></a> for the
full list of UDPs already coded in pygmo).</p>
<p>This class is the Python counterpart of the C++ class <a class="reference internal" href="../cpp/problem.html#_CPPv4N5pagmo7problemE" title="pagmo::problem"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">pagmo::problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>udp</strong> – a user-defined problem, either C++ or Python</p>
</dd>
<dt class="field-even">Raises NotImplementedError</dt>
<dd class="field-even"><p>if <em>udp</em> does not implement the mandatory methods detailed above</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if the number of objectives of the UDP is zero, the number of objectives,
    equality or inequality constraints is larger than an implementation-defined value,
    the problem bounds are invalid (e.g., they contain NaNs, the dimensionality of the lower bounds is
    different from the dimensionality of the upper bounds, etc. - note that infinite bounds are allowed),
    or if the <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> and <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> methods of the UDP fail basic sanity checks
    (e.g., they return vectors with repeated indices, they contain indices exceeding the problem’s dimensions, etc.)</p>
</dd>
<dt class="field-even">Raises unspecified</dt>
<dd class="field-even"><p>any exception thrown by methods of the UDP invoked during construction,
    the deep copy of the UDP, the constructor of the underlying C++ class,
    failures at the intersection between C++ and Python (e.g., type conversion errors, mismatched function
    signatures, etc.)</p>
</dd>
</dl>
<dl class="method">
<dt id="pygmo.problem.batch_fitness">
<code class="sig-name descname">batch_fitness</code><span class="sig-paren">(</span><em class="sig-param">dvs</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.batch_fitness" title="Permalink to this definition">¶</a></dt>
<dd><p>This method implements the evaluation of multiple decision vectors in batch mode
by invoking the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP. The <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code>
method of the UDP accepts in input a batch of decision vectors, <em>dvs</em>, stored contiguously:
for a problem with dimension <span class="math notranslate nohighlight">\(n\)</span>, the first decision vector in <em>dvs</em> occupies
the index range <span class="math notranslate nohighlight">\(\left[0, n\right)\)</span>, the second decision vector occupies the range
<span class="math notranslate nohighlight">\(\left[n, 2n\right)\)</span>, and so on. The return value is the batch of fitness vectors <em>fvs</em>
resulting from computing the fitness of the input decision vectors.
<em>fvs</em> is also stored contiguously: for a problem with fitness dimension <span class="math notranslate nohighlight">\(f\)</span>, the first fitness
vector will occupy the index range <span class="math notranslate nohighlight">\(\left[0, f\right)\)</span>, the second fitness vector
will occupy the range <span class="math notranslate nohighlight">\(\left[f, 2f\right)\)</span>, and so on.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method, this method will forward <code class="docutils literal notranslate"><span class="pre">dvs</span></code>
to the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP after sanity checks. The output of the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code>
method of the UDP will also be checked before being returned. If the UDP does not provide a
<code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method, an error will be raised.</p>
<p>A successful call of this method will increase the internal fitness evaluation counter
(see <a class="reference internal" href="#pygmo.problem.get_fevals" title="pygmo.problem.get_fevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_fevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP must be able to take as input the decision vectors as a 1D NumPy array,
and it must return the fitness vectors as an iterable Python object (e.g., 1D NumPy array, list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dvs</strong> – the decision vectors (chromosomes) to be evaluated in batch mode</p>
</dd>
<dt class="field-even">Type dvs</dt>
<dd class="field-even"><p>array-like object</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the fitness vectors of <em>dvs</em></p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if <em>dvs</em> and/or the return value are not compatible with the problem’s properties</p>
</dd>
<dt class="field-even">Raises unspecified</dt>
<dd class="field-even"><p>any exception thrown by the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.c_tol">
<em class="property">property </em><code class="sig-name descname">c_tol</code><a class="headerlink" href="#pygmo.problem.c_tol" title="Permalink to this definition">¶</a></dt>
<dd><p>Constraints tolerance.</p>
<p>This property contains an array of <code class="docutils literal notranslate"><span class="pre">float</span></code> that are used when checking for constraint feasibility.
The dimension of the array is <span class="math notranslate nohighlight">\(n_{ec} + n_{ic}\)</span> (i.e., the total number of constraints), and
the array is zero-filled on problem construction.</p>
<p>This property can also be set via a scalar, instead of an array. In such case, all the tolerances
will be set to the provided scalar value.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the constraints’ tolerances</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if, when setting this property, the size of the input array differs from the number
    of constraints of the problem or if any element of the array is negative or NaN</p>
</dd>
<dt class="field-even">Raises unspecified</dt>
<dd class="field-even"><p>any exception thrown by failures at the intersection between C++ and Python (e.g.,
    type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pygmo</span> <span class="k">import</span> <span class="n">problem</span><span class="p">,</span> <span class="n">hock_schittkowsky_71</span> <span class="k">as</span> <span class="n">hs71</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span> <span class="o">=</span> <span class="n">problem</span><span class="p">(</span><span class="n">hs71</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span>
<span class="go">array([0., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span>
<span class="go">array([1., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span>
<span class="go">array([0.5, 0.5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the user-defined problem.</p>
<p>This method allows to extract a reference to the user-defined problem (UDP) stored within this
<a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a> instance. The behaviour of this function depends on the value
of <em>t</em> (which must be a <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>) and on the type of the internal UDP:</p>
<ul class="simple">
<li><p>if the type of the UDP is <em>t</em>, then a reference to the UDP will be returned
(this mirrors the behaviour of the corresponding C++ method
<a class="reference internal" href="../cpp/problem.html#_CPPv4I0ENK5pagmo7problem7extractEPK1Tv" title="pagmo::problem::extract"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">pagmo::problem::extract()</span></code></a>),</p></li>
<li><p>if <em>t</em> is <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> and the UDP is a Python object (as opposed to an
<a class="reference internal" href="problems/py_problems.html#py-problems-cpp"><span class="std std-ref">exposed C++ problem</span></a>), then a reference to the
UDP will be returned (this allows to extract a Python UDP without knowing its type),</p></li>
<li><p>otherwise, <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a> will be returned.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> – the type of the user-defined problem to extract</p>
</dd>
<dt class="field-even">Type t</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a reference to the internal user-defined problem, or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a> if the extraction fails</p>
</dd>
<dt class="field-even">Raises TypeError</dt>
<dd class="field-even"><p>if <em>t</em> is not a <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygmo</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">problem</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">rosenbrock</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">rosenbrock</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">&lt;pygmo.core.rosenbrock at 0x7f56b870fd50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">ackley</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">prob</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">([</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">problem</span><span class="p">(</span><span class="n">prob</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">&lt;__main__.prob at 0x7f56a66b6588&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">&lt;__main__.prob at 0x7f56a66b6588&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">rosenbrock</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.feasibility_f">
<code class="sig-name descname">feasibility_f</code><span class="sig-paren">(</span><em class="sig-param">f</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.feasibility_f" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will check the feasibility of a fitness vector <em>f</em> against the tolerances returned by
<a class="reference internal" href="#pygmo.problem.c_tol" title="pygmo.problem.c_tol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">c_tol</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> – a fitness vector</p>
</dd>
<dt class="field-even">Type f</dt>
<dd class="field-even"><p>array-like object</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the fitness vector is feasible, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if the size of <em>f</em> is not the same as the output of
    <a class="reference internal" href="#pygmo.problem.get_nf" title="pygmo.problem.get_nf"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nf()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.feasibility_x">
<code class="sig-name descname">feasibility_x</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.feasibility_x" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will check the feasibility of the fitness corresponding to a decision vector <em>x</em> against
the tolerances returned by <a class="reference internal" href="#pygmo.problem.c_tol" title="pygmo.problem.c_tol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">c_tol</span></code></a>.</p>
<p>This will cause one fitness evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> – a decision vector</p>
</dd>
<dt class="field-even">Type dv</dt>
<dd class="field-even"><p>array-like object</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> results in a feasible fitness, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception thrown by <a class="reference internal" href="#pygmo.problem.feasibility_f" title="pygmo.problem.feasibility_f"><code class="xref py py-func docutils literal notranslate"><span class="pre">feasibility_f()</span></code></a> or
    <a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">fitness()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.fitness">
<code class="sig-name descname">fitness</code><span class="sig-paren">(</span><em class="sig-param">dv</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.fitness" title="Permalink to this definition">¶</a></dt>
<dd><p>Fitness.</p>
<p>This method will invoke the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP to compute the fitness of the
input decision vector <em>dv</em>. The return value of the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP is expected to have a
dimension of <span class="math notranslate nohighlight">\(n_{f} = n_{obj} + n_{ec} + n_{ic}\)</span> and to contain the concatenated values of
<span class="math notranslate nohighlight">\(\mathbf f, \mathbf c_e\)</span> and <span class="math notranslate nohighlight">\(\mathbf c_i\)</span> (in this order).
Equality constraints are all assumed in the form <span class="math notranslate nohighlight">\(c_{e_i}(\mathbf x) = 0\)</span> while inequalities are assumed in
the form <span class="math notranslate nohighlight">\(c_{i_i}(\mathbf x) &lt;= 0\)</span> so that negative values are associated to satisfied inequalities.</p>
<p>In addition to invoking the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP, this method will perform sanity checks on
<em>dv</em> and on the returned fitness vector. A successful call of this method will increase the internal fitness
evaluation counter (see <a class="reference internal" href="#pygmo.problem.get_fevals" title="pygmo.problem.get_fevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_fevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP must be able to take as input the decision vector as a 1D NumPy array, and it must
return the fitness vector as an iterable Python object (e.g., 1D NumPy array, list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> – the decision vector (chromosome) to be evaluated</p>
</dd>
<dt class="field-even">Type dv</dt>
<dd class="field-even"><p>array-like object</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the fitness of <em>dv</em></p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if either the length of <em>dv</em> differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nx" title="pygmo.problem.get_nx"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nx()</span></code></a>, or
    the length of the returned fitness vector differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nf" title="pygmo.problem.get_nf"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nf()</span></code></a></p>
</dd>
<dt class="field-even">Raises unspecified</dt>
<dd class="field-even"><p>any exception thrown by the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_bounds">
<code class="sig-name descname">get_bounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Box-bounds.</p>
<p>This method will return the box-bounds <span class="math notranslate nohighlight">\((\mathbf{lb}, \mathbf{ub})\)</span> of the problem,
as returned by the <code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> method of the UDP. Infinities in the bounds are allowed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> method of the UDP must return the box-bounds as a tuple of 2 elements,
the lower bounds vector and the upper bounds vector, which must be represented as iterable Python objects (e.g.,
1D NumPy arrays, lists, tuples, etc.). The box-bounds returned by the UDP are checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a tuple of two 1D NumPy float arrays representing the lower and upper box-bounds of the problem</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">tuple</span></code></p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception thrown by the invoked method of the underlying C++ class, or failures at the
    intersection between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_extra_info">
<code class="sig-name descname">get_extra_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_extra_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Problem’s extra info.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code> method, then this method will return the output of its <code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code>
method. Otherwise, an empty string will be returned.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">str</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>extra info about the UDP</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception thrown by the <code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code> method of the UDP</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_fevals">
<code class="sig-name descname">get_fevals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_fevals" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of fitness evaluations.</p>
<p>Each time a call to <a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">fitness()</span></code></a> successfully completes, an internal counter
is increased by one. The counter is initialised to zero upon problem construction and it is never
reset. Copy operations copy the counter as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of times <a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">fitness()</span></code></a> was successfully called</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_gevals">
<code class="sig-name descname">get_gevals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_gevals" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of gradient evaluations.</p>
<p>Each time a call to <a class="reference internal" href="#pygmo.problem.gradient" title="pygmo.problem.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> successfully completes, an internal counter
is increased by one. The counter is initialised to zero upon problem construction and it is never
reset. Copy operations copy the counter as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of times <a class="reference internal" href="#pygmo.problem.gradient" title="pygmo.problem.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> was successfully called</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_hevals">
<code class="sig-name descname">get_hevals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_hevals" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of hessians evaluations.</p>
<p>Each time a call to <a class="reference internal" href="#pygmo.problem.hessians" title="pygmo.problem.hessians"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians()</span></code></a> successfully completes, an internal counter
is increased by one. The counter is initialised to zero upon problem construction and it is never
reset. Copy operations copy the counter as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of times <a class="reference internal" href="#pygmo.problem.hessians" title="pygmo.problem.hessians"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians()</span></code></a> was successfully called</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_lb">
<code class="sig-name descname">get_lb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_lb" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower box-bounds.</p>
<p>This method will return the lower box-bounds for this problem. See <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_bounds()</span></code></a>
for a detailed explanation of how the bounds are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array representing the lower box-bounds of this problem</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception thrown by the invoked method of the underlying C++ class, or failures at the
    intersection between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_name">
<code class="sig-name descname">get_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Problem’s name.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">get_name()</span></code> method, then this method will return the output of its <code class="docutils literal notranslate"><span class="pre">get_name()</span></code> method.
Otherwise, an implementation-defined name based on the type of the UDP will be returned.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">get_name()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">str</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the problem’s name</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nc">
<code class="sig-name descname">get_nc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nc" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of constraints.</p>
<p>This method will return the sum of the output of <a class="reference internal" href="#pygmo.problem.get_nic" title="pygmo.problem.get_nic"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nic()</span></code></a> and
<a class="reference internal" href="#pygmo.problem.get_nec" title="pygmo.problem.get_nec"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nec()</span></code></a> (i.e., the total number of constraints).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the total number of constraints of the problem</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_ncx">
<code class="sig-name descname">get_ncx</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_ncx" title="Permalink to this definition">¶</a></dt>
<dd><p>Continuous dimension of the problem.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{cx}\)</span>, the continuous dimension of the problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the continuous dimension of the problem</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nec">
<code class="sig-name descname">get_nec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nec" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of equality constraints.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{ec}\)</span>, the number of equality constraints of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nec()</span></code> method of the UDP must return the number of equality constraints as an <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nec()</span></code> method, zero equality constraints will be assumed.
The number of equality constraints returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of equality constraints of the problem</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nf">
<code class="sig-name descname">get_nf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nf" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the fitness.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{f}\)</span>, the dimension of the fitness, which is the sum of
<span class="math notranslate nohighlight">\(n_{obj}\)</span>, <span class="math notranslate nohighlight">\(n_{ec}\)</span> and <span class="math notranslate nohighlight">\(n_{ic}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the dimension of the fitness</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nic">
<code class="sig-name descname">get_nic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nic" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of inequality constraints.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{ic}\)</span>, the number of inequality constraints of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nic()</span></code> method of the UDP must return the number of inequality constraints as an <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nic()</span></code> method, zero inequality constraints will be assumed.
The number of inequality constraints returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of inequality constraints of the problem</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nix">
<code class="sig-name descname">get_nix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nix" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer dimension of the problem.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{ix}\)</span>, the integer dimension of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nix()</span></code> method of the UDP must return the problem’s integer dimension as an <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nix()</span></code> method, a zero integer dimension will be assumed.
The integer dimension returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the integer dimension of the problem</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nobj">
<code class="sig-name descname">get_nobj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of objectives.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{obj}\)</span>, the number of objectives of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nobj()</span></code> method of the UDP must return the number of objectives as an <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nobj()</span></code> method, a single-objective optimizaztion problem
will be assumed. The number of objectives returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of objectives of the problem</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nx">
<code class="sig-name descname">get_nx</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nx" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the problem.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{x}\)</span>, the dimension of the problem as established by the length of
the bounds returned by <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_bounds()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the dimension of the problem</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_thread_safety">
<code class="sig-name descname">get_thread_safety</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_thread_safety" title="Permalink to this definition">¶</a></dt>
<dd><p>Problem’s thread safety level.</p>
<p>This method will return a value of the enum <a class="reference internal" href="py_misc.html#pygmo.thread_safety" title="pygmo.thread_safety"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygmo.thread_safety</span></code></a> which indicates the thread safety level
of the UDP. Unlike in C++, in Python it is not possible to re-implement this method in the UDP. That is, for C++
UDPs, the returned value will be the value returned by the <code class="docutils literal notranslate"><span class="pre">get_thread_safety()</span></code> method of the UDP. For Python
UDPs, the returned value will be unconditionally <a class="reference internal" href="py_misc.html#pygmo.thread_safety.none" title="pygmo.thread_safety.none"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pygmo.thread_safety.none</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the thread safety level of the UDP</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>a value of <a class="reference internal" href="py_misc.html#pygmo.thread_safety" title="pygmo.thread_safety"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygmo.thread_safety</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_ub">
<code class="sig-name descname">get_ub</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_ub" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper box-bounds.</p>
<p>This method will return the upper box-bounds for this problem. See <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_bounds()</span></code></a>
for a detailed explanation of how the bounds are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array representing the upper box-bounds of this problem</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception thrown by the invoked method of the underlying C++ class, or failures at the
    intersection between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">dv</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient.</p>
<p>This method will compute the gradient of the input decision vector <em>dv</em> by invoking
the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP. The <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP must return
a sparse representation of the gradient: the <span class="math notranslate nohighlight">\(k\)</span>-th term of the gradient vector
is expected to contain <span class="math notranslate nohighlight">\(\frac{\partial f_i}{\partial x_j}\)</span>, where the pair <span class="math notranslate nohighlight">\((i,j)\)</span>
is the <span class="math notranslate nohighlight">\(k\)</span>-th element of the sparsity pattern (collection of index pairs), as returned by
<a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a>.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method, this method will forward <em>dv</em> to the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code>
method of the UDP after sanity checks. The output of the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP will
also be checked before being returned. If the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method, an
error will be raised. A successful call of this method will increase the internal gradient
evaluation counter (see <a class="reference internal" href="#pygmo.problem.get_gevals" title="pygmo.problem.get_gevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_gevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP must be able to take as input the decision vector as a 1D NumPy
array, and it must return the gradient vector as an iterable Python object (e.g., 1D NumPy array,
list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> – the decision vector whose gradient will be computed</p>
</dd>
<dt class="field-even">Type dv</dt>
<dd class="field-even"><p>array-like object</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the gradient of <em>dv</em></p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if either the length of <em>dv</em> differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nx" title="pygmo.problem.get_nx"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nx()</span></code></a>, or
    the returned gradient vector does not have the same size as the vector returned by
    <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a></p>
</dd>
<dt class="field-even">Raises NotImplementedError</dt>
<dd class="field-even"><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method</p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception thrown by the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.gradient_sparsity">
<code class="sig-name descname">gradient_sparsity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.gradient_sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient sparsity pattern.</p>
<p>This method will return the gradient sparsity pattern of the problem. The gradient sparsity pattern is a lexicographically sorted
collection of the indices <span class="math notranslate nohighlight">\((i,j)\)</span> of the non-zero elements of <span class="math notranslate nohighlight">\(g_{ij} = \frac{\partial f_i}{\partial x_j}\)</span>.</p>
<p>If <a class="reference internal" href="#pygmo.problem.has_gradient_sparsity" title="pygmo.problem.has_gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method of the
UDP will be invoked, and its result returned (after sanity checks). Otherwise, a a dense pattern is assumed and the
returned vector will be <span class="math notranslate nohighlight">\(((0,0),(0,1), ... (0,n_x-1), ...(n_f-1,n_x-1))\)</span>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method of the UDP must return either a 2D NumPy array of integers, or an iterable
Python object of any kind. Specifically:</p>
<ul class="simple">
<li><p>if the returned value is a NumPy array, its shape must be <span class="math notranslate nohighlight">\((n,2)\)</span> (with <span class="math notranslate nohighlight">\(n \geq 0\)</span>),</p></li>
<li><p>if the returned value is an iterable Python object, then its elements must in turn be iterable Python objects
containing each exactly 2 elements representing the indices <span class="math notranslate nohighlight">\((i,j)\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the gradient sparsity pattern</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>2D Numpy int array</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if the NumPy array returned by the UDP does not satisfy the requirements described above (e.g., invalid
    shape, dimensions, etc.),
    at least one element of the returned iterable Python object does not consist of a collection of exactly
    2 elements, or the sparsity pattern returned by the UDP is invalid
    (specifically, if it is not strictly sorted lexicographically,
    or if the indices in the pattern are incompatible with the properties of the problem, or if the size of the
    returned pattern is different from the size recorded upon construction)</p>
</dd>
<dt class="field-even">Raises OverflowError</dt>
<dd class="field-even"><p>if the NumPy array returned by the UDP contains integer values which are negative or outside an
    implementation-defined range</p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception thrown by the underlying C++ function,
    the <code class="docutils literal notranslate"><span class="pre">PyArray_FROM_OTF()</span></code> function from the NumPy C API, or
    failures at the intersection between C++ and Python (e.g., type conversion errors, mismatched function
    signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_batch_fitness">
<code class="sig-name descname">has_batch_fitness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_batch_fitness" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.batch_fitness" title="pygmo.problem.batch_fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">batch_fitness()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method in the UDP</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_gradient">
<code class="sig-name descname">has_gradient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the gradient is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the gradient is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the gradient is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.gradient" title="pygmo.problem.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the gradient in the UDP</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_gradient_sparsity">
<code class="sig-name descname">has_gradient_sparsity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_gradient_sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the gradient sparsity is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the gradient sparsity is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the gradient sparsity is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code>
method, then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method and a <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code> method,
then this method will return the output of the <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Regardless of what this method returns, the <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a> method will always
return a sparsity pattern: if the UDP does not provide the gradient sparsity, pygmo will assume that the sparsity
pattern of the gradient is dense. See <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a> for more details.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the gradient sparsity in the UDP</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_hessians">
<code class="sig-name descname">has_hessians</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_hessians" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the hessians are available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the hessians are available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the hessians is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.hessians" title="pygmo.problem.hessians"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the hessians in the UDP</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_hessians_sparsity">
<code class="sig-name descname">has_hessians_sparsity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_hessians_sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the hessians sparsity is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the hessians sparsity is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the hessians sparsity is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code>
method, then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method and a <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code> method,
then this method will return the output of the <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Regardless of what this method returns, the <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a> method will always
return a sparsity pattern: if the UDP does not provide the hessians sparsity, pygmo will assume that the sparsity
pattern of the hessians is dense. See <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a> for more details.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the hessians sparsity in the UDP</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_set_seed">
<code class="sig-name descname">has_set_seed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_set_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.set_seed" title="pygmo.problem.set_seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_seed()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method in the UDP</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.hessians">
<code class="sig-name descname">hessians</code><span class="sig-paren">(</span><em class="sig-param">dv</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.hessians" title="Permalink to this definition">¶</a></dt>
<dd><p>Hessians.</p>
<p>This method will compute the hessians of the input decision vector <em>dv</em> by invoking
the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP. The <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP must return
a sparse representation of the hessians: the element <span class="math notranslate nohighlight">\(l\)</span> of the returned vector contains
<span class="math notranslate nohighlight">\(h^l_{ij} = \frac{\partial f^2_l}{\partial x_i\partial x_j}\)</span> in the order specified by the
<span class="math notranslate nohighlight">\(l\)</span>-th element of the hessians sparsity pattern (a vector of index pairs <span class="math notranslate nohighlight">\((i,j)\)</span>)
as returned by <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a>. Since
the hessians are symmetric, their sparse representation contains only lower triangular elements.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method, this method will forward <em>dv</em> to the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code>
method of the UDP after sanity checks. The output of the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP will
also be checked before being returned. If the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method, an
error will be raised. A successful call of this method will increase the internal hessians
evaluation counter (see <a class="reference internal" href="#pygmo.problem.get_hevals" title="pygmo.problem.get_hevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_hevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP must be able to take as input the decision vector as a 1D NumPy
array, and it must return the hessians vector as an iterable Python object (e.g., list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> – the decision vector whose hessians will be computed</p>
</dd>
<dt class="field-even">Type dv</dt>
<dd class="field-even"><p>array-like object</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the hessians of <em>dv</em></p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of 1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if the length of <em>dv</em> differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nx" title="pygmo.problem.get_nx"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nx()</span></code></a>, or
    the length of returned hessians does not match the corresponding hessians sparsity pattern dimensions, or
    the size of the return value is not equal to the fitness dimension</p>
</dd>
<dt class="field-even">Raises NotImplementedError</dt>
<dd class="field-even"><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method</p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception thrown by the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.hessians_sparsity">
<code class="sig-name descname">hessians_sparsity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.hessians_sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Hessians sparsity pattern.</p>
<p>This method will return the hessians sparsity pattern of the problem. Each component <span class="math notranslate nohighlight">\(l\)</span> of the hessians
sparsity pattern is a lexicographically sorted collection of the indices <span class="math notranslate nohighlight">\((i,j)\)</span> of the non-zero elements of
<span class="math notranslate nohighlight">\(h^l_{ij} = \frac{\partial f^l}{\partial x_i\partial x_j}\)</span>. Since the Hessian matrix is symmetric, only
lower triangular elements are allowed.</p>
<p>If <a class="reference internal" href="#pygmo.problem.has_hessians_sparsity" title="pygmo.problem.has_hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method of the
UDP will be invoked, and its result returned (after sanity checks). Otherwise, a dense pattern is assumed and
<span class="math notranslate nohighlight">\(n_f\)</span> sparsity patterns containing <span class="math notranslate nohighlight">\(((0,0),(1,0), (1,1), (2,0) ... (n_x-1,n_x-1))\)</span> will be returned.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method of the UDP must return an iterable Python object of any kind. Each element of the
returned object will then be interpreted as a sparsity pattern in the same way as described in
<a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a>. Specifically:</p>
<ul class="simple">
<li><p>if the element is a NumPy array, its shape must be <span class="math notranslate nohighlight">\((n,2)\)</span> (with <span class="math notranslate nohighlight">\(n \geq 0\)</span>),</p></li>
<li><p>if the element is itself an iterable Python object, then its elements must in turn be iterable Python objects
containing each exactly 2 elements representing the indices <span class="math notranslate nohighlight">\((i,j)\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the hessians sparsity patterns</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of 2D Numpy int array</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if the NumPy arrays returned by the UDP do not satisfy the requirements described above (e.g., invalid
    shape, dimensions, etc.),
    at least one element of a returned iterable Python object does not consist of a collection of exactly
    2 elements, or if a sparsity pattern returned by the UDP is invalid (specifically, if it is not strictly sorted lexicographically,
    if the indices in the pattern are incompatible with the properties of the problem or if the size of the pattern
    differs from the size recorded upon construction)</p>
</dd>
<dt class="field-even">Raises OverflowError</dt>
<dd class="field-even"><p>if the NumPy arrays returned by the UDP contain integer values which are negative or outside an
    implementation-defined range</p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception thrown by the underlying C++ function,
    the <code class="docutils literal notranslate"><span class="pre">PyArray_FROM_OTF()</span></code> function from the NumPy C API, or
    failures at the intersection between C++ and Python (e.g., type conversion errors, mismatched function
    signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.is_">
<code class="sig-name descname">is_</code><span class="sig-paren">(</span><em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.is_" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the type of the user-defined problem.</p>
<p>This method returns <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">False</span></code></a> if <a class="reference internal" href="#pygmo.problem.extract" title="pygmo.problem.extract"><code class="xref py py-func docutils literal notranslate"><span class="pre">extract(t)</span></code></a> returns
<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a>, and <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code></a> otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> – the type that will be compared to the type of the UDP</p>
</dd>
<dt class="field-even">Type t</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>whether the UDP is of type <em>t</em> or not</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception thrown by <a class="reference internal" href="#pygmo.problem.extract" title="pygmo.problem.extract"><code class="xref py py-func docutils literal notranslate"><span class="pre">extract()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.is_stochastic">
<code class="sig-name descname">is_stochastic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.is_stochastic" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <a class="reference internal" href="#pygmo.problem.has_set_seed" title="pygmo.problem.has_set_seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_set_seed()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.set_seed">
<code class="sig-name descname">set_seed</code><span class="sig-paren">(</span><em class="sig-param">seed</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.set_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the seed for the stochastic variables.</p>
<p>This method will set the seed to be used in the fitness function to instantiate
all stochastic variables. If the UDP provides a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method, then
its <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method will be invoked. Otherwise, an error will be raised.
The <em>seed</em> parameter must be non-negative.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method of the UDP must be able to take an <code class="docutils literal notranslate"><span class="pre">int</span></code> as input parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seed</strong> – the desired seed value</p>
</dd>
<dt class="field-even">Type seed</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Raises NotImplementedError</dt>
<dd class="field-odd"><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method</p>
</dd>
<dt class="field-even">Raises OverflowError</dt>
<dd class="field-even"><p>if <em>seed</em> is negative</p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>any exception raised by the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method of the UDP or failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2018, pagmo development team.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>